- **Solana上所有数据都存储在 account 中**

    - 账户最多可以存储 10MiB 的数据，这些数据可以是可执行的程序代码或程序状态。

    - 账户需要支付与存储数据量成比例的 租金押金 （以 lamports 或 SOL 计），当你关闭账户时可以完全取回。

    - 每个账户都有一个程序 所有者。只有拥有账户的程序可以更改其数据或扣除其 lamport 余额，但任何人都可以增加余额。

    - **Sysvar 账户**是存储网络集群状态的特殊账户。

    - **程序账户**存储智能合约的可执行代码。

    - **数据账户**由程序创建，用于存储和管理程序状态。

    - 每个 Solana 账户都有一个唯一的 32 字节地址，通常显示为 base58 编码的字符串。

    - 为了在链上存储数据，账户必须保持与账户中存储的数据量（以字节为单位）成比例的 lamport (SOL) 余额。这个余额被称为“rent”，但它更像是一种押金，因为当您关闭账户时，可以取回全部金额。您可以在这里找到计算方法，并使用这些常量。

- **基础账户属性**

    每个账户都有以下字段

    - `Lamports`

        - lamport 是 SOL 的最小单位（1 SOL = 10 亿 lamport）。

        - Solana 账户必须拥有与账户中存储的数据量（以字节为单位）成比例的最低 lamport 余额，此最低余额称为“租金”。

        - 当账户关闭时，存储在账户中的 lamport 余额可以完全恢复。

    - `data`

        - 一个字节数组，用于存储账户的任意数据，该数据字段通常被称为“account data”。

        - 对于程序账户（智能合约），此字段包含可执行程序代码本身或存储可执行程序代码的另一个账户的地址。

        - 对于非可执行账户，此字段通常存储需要被读取的状态。

    - `owner`

        - 拥有此账户的程序的程序 ID（公钥）。

        - 每个 Solana 账户都有一个指定的程序作为其所有者。只有拥有账户的程序可以更改账户的数据或扣除其 lamports 余额。

        - 程序中定义的指令决定了账户的数据和 lamports 余额可以如何更改。

    - `executable`

        - 如果 `true`，该账户是一个可执行的 Solana 程序。

        - 如果 `false`，该账户是存储状态的数据账户。

    - `rent_epoch`

        - `rent_epoch` 字段是一个已不再使用的遗留字段。

        - 最初，该字段用于跟踪账户何时需要支付租金（以 lamports 计）以维护其在网络上的数据。然而，这种租金收取机制现已被弃用。

- **BPF Loader（伯克利数据包过滤器）**

    BPF loader（Berkeley Packet Filter Loader） 高效的代码执行引擎，负责把开发者写的程序加载到区块链上运行，同时确保这些程序安全、合规。

    - **使用 BPF loader 的原因**

        - BPF 引擎运行代码的速度极快，能支撑 Solana 每秒处理几千笔交易。

        - BPF 的安全机制能严格限制代码的权限（比如只能访问指定账户，不能乱读乱改），避免恶意合约拖垮网络。

    - **BPF loader 干了什么**

        - 验证智能合约是否合法

            - 检查代码有没有恶意逻辑（比如偷偷转走用户资产）；

            - 确保代码符合 Solana 的运行规则（比如不能无限占用资源拖慢网络）。

        - 把合约加载到区块链上运行

            - 安检通过后，BPF loader 会把智能合约的代码存储到 Solana 的账户里，并负责在用户调用合约时（比如转账、 mint NFT），把代码加载到网络节点的 BPF 虚拟机里执行。

        - 管理合约的升级和更新

            - 早期的 BPF loader 不支持升级（合约一旦上链就改不了）；

            - 现在常用的 BPF loader 支持安全升级。

- **System Program（系统程序）拥有者：System Program**

    默认情况下，所有**新账户**都归 System Program 所有。

    System Program 执行以下关键功能：

    - 新账户创建

    - 空间分配

    - 分配程序所有权

    - 转移SOL

    当 SOL 第一次发送到一个新地址时，会自动在该地址创建一个由 System Program 拥有的账户。

- **Sysvar Account（系统变量账户）拥有者：System Program**

    Solana 网络自己维护的、专门存 “全网络都需要用的公共信息” 的账户。这些账户会动态更新网络集群的相关数据。

    - Clock（时钟账户）：告诉所有人 / 合约 “现在是 Solana 网络的第几秒”。比如某 NFT 活动 “只到 2024 年 12 月”，合约就查这个账户判断 “现在该不该停止活动”。

    - Rent（租金账户）：告诉所有人 / 合约 “Solana 账户要交多少租金才能不被删除”。比如你创建一个账户，得按这里的标准存够 SOL 当租金，不然账户会被清掉。

    - SlotHashes（区块哈希账户）：存每一个 “区块”（Solana 打包交易的单位）的 “唯一编号”。比如合约要确认 “某笔交易是不是真的上链了”，就查这里的编号对不对。

- **Program Account（程序账户）拥有者：BPF Loader**

    部署一个 Solana 程序会创建一个可执行的 program account。program account 存储程序的可执行代码。program account 由 Loader Program 拥有。

- **Buffer Account（缓冲区账户）拥有者：Program Account**

    用来暂时存放数据，等处理完后再把数据转移到最终的目标账户里。

    - **Buffer Account 用途**

        Solana 中，智能合约（程序）处理数据时，经常会遇到两种情况：

        - **数据太大，直接操作目标账户不方便**
比如创建一个复杂的 NFT 时，元数据（图片链接、描述、属性等）可能很长，直接往 NFT 账户里写容易出错。这时就先把元数据存到 Buffer Account 里，慢慢校验、修改格式，确认无误后再 “搬家” 到正式的 NFT 账户。

        - **操作步骤多，需要临时存中间结果**
比如某个 DeFi 合约要做一系列计算（比如先算汇率、再算手续费、最后算收益），中间结果如果直接存在最终账户里，一旦某步出错就很难回滚。用 Buffer Account 暂存中间结果，所有步骤确认正确后再一次性写入最终账户，更安全高效。

    - **和普通账户的核心区别**

        - **普通账户**：存的是 “最终数据”（比如你的 SOL 余额、NFT 正式元数据），需要长期保留，通常要交租金（或存够 SOL 豁免租金）。

        - **Buffer Account**：存的是 “临时数据”（中间结果、待处理的草稿），用完就可能被清空或销毁，不需要长期保留，更像 “一次性工具”。

- **Program Data Account（程序数据账户）拥有者：Program Account**

    - 专门为 “可升级程序” 设计的核心账户，用于存储程序的实际字节码（可执行代码），是可升级程序架构中 “代码与元数据分离” 设计的关键组成部分。

    - 它仅存在于由可升级加载器（如`BPF Upgradeable Loader v3`、`v4`）部署的程序中，与`Program Account`（程序账户）共同构成可升级程序的完整结构。

    - **定位与作用**

        - **代码与标识分离**：程序的唯一标识（Program ID）由`Program Account`持有，而代码存储在`Program Data Account`中，确保程序升级时`Program ID`不变（避免依赖该程序的其他账户 / 交易失效）。

        - **安全升级控制**：通过严格的权限设计，仅允许授权主体（如 “升级权限账户”）通过加载器更新代码，防止未授权篡改。

    - **核心属性与特征**

        - **存储内容**：存储程序编译后的字节码（BPF 格式指令集），是程序逻辑的实际载体。例如，一个 NFT 铸造程序的`Program Data Account`中存储的是处理铸造、转账、销毁等逻辑的二进制代码。

        - **可执行性**：`Executable`字段为`false`（非可执行账户），仅作为数据存储，不直接参与代码执行。代码执行时，由`Program Account`（可执行账户）指向它并加载代码。

        - **所有权**：是对应的`Program Account`的公钥（即程序 ID）。这意味着：

            - 只有`Program Account`有权限修改`Program Data Account`的内容（如升级时替换代码）。

            - 而`Program Account`的所有者是可升级加载器（如`loader-v3`/`v4`），形成 “双层权限管控”（加载器 → Program Account → Program Data Account）。

        - **租金豁免**：与其他账户一样，`Program Data Account`需存储足够的 Lamports 以满足 “租金豁免阈值”（根据代码大小计算），否则会被定期扣除租金。

        - **地址生成**：地址由可升级加载器在部署时自动生成，通常与`Program Account`的地址存在确定性关联（通过种子和加载器程序 ID 推导），确保`Program Account`能稳定指向它。

- **Data Account（数据账户）拥有者：Program Account**

    Data Account（数据账户）是专门用于存储链上状态数据的非可执行账户，是 “程序与状态分离” 架构的核心组成部分。所有链上业务数据（如用户余额、代币信息、NFT 元数据、合约配置等）均通过数据账户存储，其设计直接影响 Solana 的性能、安全性和开发模式。

    - **核心定义与定位**

        - 程序账户负责提供逻辑（代码），数据账户负责存储状态（数据）；

        - 程序通过读取 / 修改数据账户的内容实现业务功能（如转账时修改双方余额账户的数据）；

        - 任何链上状态的变更，本质都是数据账户中字节数组的修改。

    - **主要类型与典型场景**

        - **用户基础账户（System Account）**

            - 由`System Program`（系统程序）创建，用于存储用户的 SOL 余额。

            - Owner 是`System Program`（公钥：`11111111111111111111111111111111`）。

        - **SPL 代币账户**

            - 由`SPL Token Program`创建，用于存储用户的代币余额（如USDC等）。

            - Owner 是`SPL Token Program`（公钥：`TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`）。

            - `Data`字段存储代币 mint 地址、余额、授权信息等（遵循 SPL 代币标准结构体）。

        - **NFT 元数据账户**

            - 由`Metaplex Token Metadata Program`创建，存储 NFT 的元数据（名称、描述、图片 URL 等）。

            - Owner 是元数据程序的公钥，`Data`字段按 Metaplex 标准存储结构化元数据（如`name`、`uri`、`seller_fee_basis_points`等）。

        - **程序派生地址（PDA）账户**

            - 由程序通过种子（Seeds）和程序 ID 派生的特殊数据账户（无对应私钥），用于存储程序的结构化状态（如订单数据、用户配置）。

            - Owner 是派生它的程序 ID，例如：一个 DeFi 协议的 PDA 账户存储用户的质押信息，Owner 是该 DeFi 程序的公钥。

        - **Buffer 账户**

            - 用于存储临时数据或辅助数据（如交易中间状态、批量处理的缓存数据），Owner 是创建它的业务程序。

